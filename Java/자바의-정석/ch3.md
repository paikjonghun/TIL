## 연산자와 피연산자

- 연산자 : 연산을 수행하는 기호(+, -, *, / 등)
- 피연산자 : 연산자의 연산 수행 대상(x, y, 3 등)
- 모든 연산자는 연산 결과를 반환한다.

## 연산자의 종류

- 산술 연산자 : `+, -, *, /, %` - 사칙 연산과 나머지 연산(%)
- 비교 연산자 : `>, <, ≥, ≤, ==, ≠` - 크고 작음과 같고 다름을 비교
- 논리 연산자 : `&&, ||, !` - 그리고(AND)와 또는(OR)으로 조건을 연결
- 대입 연산자 : `=` - 우변의 값을 좌변에 저장
- 기타 : `(type), ?:, instanceof` - 형변환 연산자, 삼항 연산자, instanceof 연산자

## 연산자의 우선순위

- 하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할 지를 자동 결정하는 것
- 괄호를 활용해서 수동 결정할 수 있다.

- 단항 연산자가 이항 연산자보다 우선순위가 높다.
- 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높다.
- 비교 연산자보다 산술 연산자가 먼저 수행된다.
- 논리연산자보다 비교 연산자가 먼저 수행된다.
- 대입 연산자는 연산자 중에서 제일 우선순위가 낮다.

## 연산자의 결합규칙

- 결합규칙 : 우선순위가 같은 연산자가 있을 때, 어떤 것을 먼저할 것인가?
    - 대입과 단한 연산자를 제외하면, 모두 왼쪽에서 오른쪽으로 연산

## 연산자의 우선순위와 결합법칙은 세 가지만 기억하기

1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

## 증감 연산자

- 증가 연산자(++) - 피연산자의 값을 1 증가시킨다.
- 감소 연산자(--) - 피연산자의 값을 1 감소시킨다.

- 전위형 : 값이 참조되기 전에 증가시킨다.
    - `j = ++i;`
    
    ```java
    ++i; // 증가 후에
    j = i; // 참조하여 대입
    ```
    
- 후위형 : 값이 참조된 후에 증가시킨다.
    - `j = i++;`
    
    ```java
    j = i; // 참조하여 대입 후에
    i++; // 증가
    ```
    
- 증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다.

## 부호 연산자

- ‘-’는 피연산자의 부호를 반대로 변경
- ‘+’는 아무런 일도 하지 않는다.(실제로 사용 X)

## 형변환 연산자

- 형변환 - 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- (타입)피연산자
    - double d = 85.4;
    - int scroe = (int)d;

- int → char : `(char)65` → ‘A’
- char → int : `(int)’A’` → 65
- float → int : `(int)1.6f` → 1
- int → float : `(float)10` → 10.0f

## 자동 형변환

```java
float f = 1234; // int 타입의 값을 float 타입의 변수에 저장. 형변환이 생략된 것임.
float f = (float)1234; // 컴파일러가 이 형태로 자동으로 형변환. 
```

```java
int i = 3.14f; // 에러 발생. float 범위가 넓은데 작은 integer 범위에 넣으려고 하면 오류.
int i = (int)3.14f; // 값 손실이 발생할 수 있기 때문에 수동 형변환을 해야함.
```

1. byte → int
    
    ```java
    byte b = 10;
    int i = b; // 형변환 생략 가능. byte는 1byte. int는 4byte. 값손실 없으므로 자동 형변환.
    ```
    
2. int → byte
    
    ```java
    int i2 = 300;
    byte b2 = (byte)i2; // 형변환 생략 불가. 값손실 있을 수 있으므로 수동 형변환 해야 함.
    ```
    

- 형변환을 생략하면 컴파일러가 알아서 자동으로 형변환을 한다. 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 된다. 표현범위가 좁은 타입에서 넓은 타입으로 형변화는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.

- 예외적 상황
    
    ```java
    byte b = 100; // OK. byte타입의 범위(-128 ~ 127)의 값의 대입
    byte b = (byte)100; // OK. byte타입으로 자동 형변환하여 대입. 값 손실이 없기 때문에 가능.
    ```
    
    ```java
    int i = 100;
    byte b = i; // 에러. int타입을 byte타입에 대입. 변수라서 변수 안에 어떤 값이 있는지 컴파일러는 
    						// 알 수 없다. 수동 형변환을 해야함.
    byte b = (byte)i; // OK. bytexㅏ입으로 형변환하여 대입
    ```
    
    ```java
    byte b = 1000; // 에러. byte타입의 범위(-128 ~ 128)를 벗어난 값의 대입.
    								// 값 손실이 있기 때문에 자동 형변환이 안됨.
    byte b = (byte)1000; // OK. 그러나 값손실이 발생해서 변수 b에는 -24가 저장됨.
    ```

## 사칙 연산자 - 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/)

- int 10 을 int 4로 나누면 int 2가 출력됨. 소수점 이하는 버려진다.
- int 10을 float 4.0f로 나누면 int 10이 float 10.0f이 되어 나눠진다.. → `10.0f / 4.0f` → `2.5f`

## 산술 변환

- 연산 전에 피연산자의 타입을 일치시키는 것
    1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)
        1. long + int → long + long → long
        2. float + int → float + float → float
        3. double + float → double + double → double
    2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
        1. byte + short → int + int → int
        2. char + short → int + int → int
        
        정수의 오버플로우 발생을 막기 위해서 int로 자동 형변환된다.

## 반올림 - Math.round()

- 실수를 소수점 첫 째자리에서 반올림한 정수를 반환
    
    ```java
    long result = Math.round(4.52); // result에 5가 저장된다.
    ```
    
- 소수점 넷 째자리에서 반올림 하려면
    
    ```java
    double pi = 3.141592;
    double shortPi = Math.round(pi * 1000) / 1000.0;
    
    // 풀어서 보자면
    double shortPi = Math.round(pi * 1000) / 1000.0;
    double shortPi = Math.round(3.141592 * 1000) / 1000.0;
    double shortPi = Math.round(3141.592) / 1000.0;
    // 1000.0으로 나누는 이유는 int 나누기 int는 정수이기 때문.
    double shortPi = 3142 / 1000.0;
    double shortPi = 3.142;
    ```
    
- pi 변수에서 3.141을 얻으려면
    
    ```java
    pi * 1000
    (int)(pi * 1000)
    (int)(pi * 1000) / 1000.0 // 3.141
    ```
    

## 나머지 연산자 - %

- 오른쪽 피연산자로 나누고 남은 나머지를 반환. 나누는 피연산자는 0이 아닌 정수만 허용(부호는 무시됨)
    
    ```java
    System.out.println(10 % 8); // 10을 8로 나눈 나머지 2가 출력된다.
    System.out.println(10 % -8); // 위와 같은 결과를 얻는다.
    ```

## 비교 연산자 - >, <, ≥, ≤, ==, ≠

- 두 피연산자를 비교해서 true(참) 또는 false(거짓)을 반환
    - >
    - <
    - `<=` : =은 뒤에 와야함.
    - `<=` : =은 뒤에 와야함.
    - ==
    - `!=` : !가 뒤에 오면 안됨.

## 문자열 비교

- 문자열 비교에는 == 대신 equals()를 사용해야 한다.
  
## 논리 연산자 - &&, ||

- 조건식을 연결할 때 사용하는 연산자
    - ||(OR 결합) - 피연산자 중 어느 한 쪽이 true이면 true를 결과로 얻는다.
    - &&(AND 결합) - 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.

## 논리 부정 연산자 - !

- ture를 false로, false를 true로 바꾼다.
    
    ```java
    boolean b = true;
    // !!b -> !!ture -> !false -> true
    ```

## 조건 연산자(삼항 연산자) - ? :

- 조건식의 결과에 따라 연산결과를 달리한다.
    - 조건식 ? 식1 : 식2
    
    ```java
    result = (x > y) ? x : y; // 괄호 생략 가능
    // 참이면 x가 대입, 거짓이면 y가 대입
    ```
    
    - if문을 간단하게 쓰기 위해서 조건 연산자를 사용한다.

## 대입 연산자

- 오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환. 연산 순서는 오른쪽에서 왼쪽으로 진행.
    
    ```java
    System.out.println(x = 3); // 변수 x에 3이 저장되고 연산 결과인 3이 출력된다.
    System.out.pirntln(3);
    ```
    
- lvalue - 대입 연산자의 왼쪽 피연산자. 저장 공간(변수, 배열 등). 값을 저장하 수 있는 공간이어야 함.
- rvlaue - 대입 연산자의 오른쪽 피연산자

## 복합 대입 연산자

- 대입 연산자와 다른 연산자를 하나로 축약
    - `i += 3;` → `i = i + 3;`
    - 다른 연산자 모두 같은 원리.


