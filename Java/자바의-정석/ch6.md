## 객체지향 언어

80년대 초반 소프트웨어의 위기 - 빠른 변화를 못 쫓아감.

해결책으로 객체지향 언어를 도입(절차적 → 객체지향)

코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거. - 객체 지향 언어의 장점

객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙) - 기본적인 언어에서 규칙들이 추가된 것.

객체 지향 언어(Object Oriented Programming)의 핵심 개념

1. 캡슐화
2. 상속
3. 추상화
4. 다형성

- 객체지향 개념은 어떻게 공부해야 하는가?
    - 객체지향 개념과 규칙들을 일단 외우기!
    - 실습 위주로 공부하기

## 클래스와 객체

- 클래스의 정의
    - 클래스란 객체를 정의해 놓은 것
- 클래스의 용도
    - 클래스는 객체를 생성하는데 사용

- 객체의 정의
    - 실제로 존재하는 것. 사물 또는 개념
- 객체의 용도
    - 객체가 가지고 있는 기능과 속성에 따라 다름

| 클래스 | 객체 |
| --- | --- |
| 제품 설계도 | 제품 |
| TV 설계도 | TV |
| 붕어빵 기계 | 붕어빵 |

## 객체의 구성요소 - 속성과 기능

- 객체 = 속성(변수) + 기능(메소드)
    - 속성 : 크기, 길이, 높이, 색상, 볼륨, 채널 등
    - 기능 : 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등
- 속성은 변수로, 기능은 메소드로 정의해서 하나의 클래스를 만듦.

## 객체와 인스턴스

- 객체 : 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스 : 특정 클래스로부터 생성된 객체(예:TV인스턴스)

- 인스턴스화
    - 클래스(설계도) → 인스턴스(객체)(제품)

## 클래스와 객체

- 클래스(설계도)가 왜 필요한가? - 객체(제품)를 생성하기 위해서
- 객체(제품)가 왜 필요한가? - 객체(제품)을 사용하기 위해서
- 객체를 사용한다는 것은? - 객체가 가진 속성과 기능을 사용하는 것

## 하나의 소스파일에 여러 클래스 작성

- 가능하다면 하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직하다!

- public class가 있는 경우, 소스파일의 이름은 반드시 public class의 이름과 일치해야 한다.
- public class가 하나도 없는 경우, 소스파일의 이름은 ‘Hello2.java’, ‘Hello3.java’ 둘 다 가능하다.

- 잘못된 작성
    - 하나의 소스파일에 둘 이상의 public class가 존재하면 안된다. 각 클래스를 별도의 소스파일에 나눠서 저장하거나 둘 중의 한 클래스에 public을 붙이지 않아야 한다.
    - 소스파일의 이름이 public class와 이름이 일치하지 않는 경우, 소스파일의 이름을 수정해야 한다.
    - 자바는 대소문자를 구분하므로 소스파일의 이름과 public class의 이름의 대소문자까지 일치해야한다.

## 객체의 생성과 사용

1. 객체의 생성

```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조 변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t; // Tv클래스 타입의 참조변수 t를 선언
t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```

1. 객체의 사용

```java
t.channel = 7; // Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
t.channelDown(); // Tv인스턴스의 메소드 channelDown()을 호출한다.
System.out.println("현재 채널은 " + t.channel + " 입니다.");
```

1. 클래스(설계도) 작성
2. 객체(제품) 생성
3. 객체(제품) 사용 - 변수와 메소드

- 하나의 인스턴스를 여러 개의 참조변수가 가리키는 경우는 가능
- 여러 인스턴스를 하나의 참조변수가 가리키는 경우는 불가능

## 객체 배열

- 객체 배열 == 참조변수 배열

```java
Tv tv1, tv2, tv3; // 이것을 객체 배열로 표현 가능

Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 객체 배열 생성 방법 2
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
```

## 클래스의 정의(1)

- 클래스
    1. 설계도
    2. 데이터 + 함수(데이터와 함수의 결합)
    3. 사용자 정의 타입

- 클래스 == 데이터 + 함수

1. 변수 - 하나의 데이터를 저장할 수 있는 공간
2. 배열 - 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체 - 서로 관련된 여러 데이터(종류 관계 X)를 하나로 저장할 수 있는 공간
4. 클래스 - 데이터와 함수의 결합(구조체 + 함수)

## 클래스 정의(2)

- 사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.

```java
// 시간을 일일이 만들 필요 없이
int hour1, hour2, hour3
int minute1, minute2, minute3
int second1, second2, second3

// 클래스로 타입을 만들면 사용이 더 편리하다.
class Time {
	int hour;
	int minute;
	int second;
}

// 시, 분, 초가 한번에 묶여서 더 편리하다.
Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();
```

## 선언 위치에 따른 변수의 종류

```java
class Variables {
	int iv; // 인스턴스 변수
	static int cv; // 클래스 변수(static 변수, 공유 변수)
	
	void method() {
		int lv = 0; // 지역 변수
	}
}
```

- 클래스의 영역
    1. 클래스 영역(클래스 안쪽 전체 영역 - 클래스 시작부터 끝까지) - iv, cv
        1. 클래스 영역에는 선언문만 작성 가능 - 변수 선언, 메소드 선언(메소드 정의)
        2. 선언문의 순서는 상관 없다. 일반적으로 변수 선언을 먼저 한다.
    2. 메소드 영역(메소드 안쪽 영역 - 메소드 시작부터 끝까지) - lv

| 변수의 종류 | 선언 위치 | 생성시기 |
| --- | --- | --- |
| 클래스 변수(class variable) | 클래스 영역 | 클래스가 메모리에 올라갈 때 (따라서 cv는 객체 생성이 필요 없다. 아무 때나 사용 가능.) |
| 인스턴스 변수(instance variable) | 클래스 영역 | 인스턴스가 생성되었을 때(객체 생성을 해야 사용할 수 있다.) |
| 지역 변수(local variable) | 클래스 영역 이외의 영역(메소드 생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때 (메소드 종료시 자동 제거) |

## 클래스 변수와 인스턴스 변수

- 개별 속성을 가져야 하는 것은 - 인스턴스 변수
- 공통 속성을 가져야 하는 것은 - 클래스 변수

```java
class Card {
	String kind; // 무늬
	int number; // 숫자

	static int width = 100; // 폭
	static int height = 250; // 높이
}

Card c = new Card();
c.kind = "HEART";
c.number = 5;
c.width = 200; // -> Card.width = 200;
c.height = 300; // -> Card.height = 300; cv는 클래스 이름을 붙이는 것이 좋음.
								// cv는 참조변수가 아니기 때문.
```

## 메소드란?

1. 문장들을 {}블럭으로 묶어놓은 것.
    1. 작업 단위로 문장들을 묶어서 이름 붙인 것.
2. 값(입력)을 받아서 처리하고, 결과를 반환(출력)할 수 있음.
    1. 입력은 0~n개 가능. 출력은 0~1개
    2. 출력을 여러개 해야하면 배열이나 객체로 출력.

- 메소드의 장점
    - 코드의 중복을 줄일 수 있다.
    - 코드의 관리가 쉽다.
    - 코드를 재사용할 수 있다.
    - 코드가 간결해서 이해하기 쉬워진다.

- 메소드의 작성
    - 반복적으로 수행되는 여러 문장을 메소드로 작성
    - 하나의 메소드는 한 가지 기능만 수행하도록 작성

- 메소드 = 선언부 + 구현부
    
    ```java
    반환타입 메소드이름(타입 변수명, 타입 변수명, ...) // 선언부
    { // 구현부
    
    	// 메소드 호출 시 수행될 코드
    
    }
    ```
    
- 지역 변수(lv) : 메소드 내에 선언된 변수
    - 매개변수도 지역변수. 메소드 내에서만 사용 가능.


## 메소드의 호출

- 메소드를 호출해야 {} 괄호 안의 문장들이 실행된다.

```java
메소드이름(값1, 값2, ...); // 메소드를 호출하는 방법. 값에는 작업에 필요한 값들을 쓴다. 없으면 안넣으면 됨.

print99damAll(); // void print99danAll()을 호출. 반환타입이 void라서 반환이 없다는 것.
int result = add(3, 5); // int add(int x, int y)를 호출하고, 결과를 result에 저장. 두 개의 값을 주면 int 타입을 돌려준다. 작업 결과를 저장할 변수가 있어야 함.(없어도 오류는 안 남)
```

- 매개변수(parameter, 복사본) - 메소드에 전달하는 중간 매개체 역할.
- 메소드는 클래스의 영역에만 정의 가능.
- 반환타입이 있는 메소드를 호출하고 저장할 곳이 없으면 결과가 그냥 사라짐. (반환 타입이 있어도 void인 메소드처럼 호출 가능은 함)

```java
long add(long a, long b) {
	long result = a + b;
	return result;
//return a + b; // 위의 두 줄을 이와 같이 한 줄로 간단히 할 수 있다.
```

## 메소드의 실행흐름

```java
MyMath mm = new MyMath); // 먼저 인스턴스를 생성한다.
long value = mm.add(1L, 2L); // 메소드를 호출한다.

long add(long a, long b) {
	long result = a + b;
	return result;
}
```

1. main 메소드에서 메소드 add를 호출한다. 인수 1L과 2L이 메소드 add의 매개변수 a, b에 각각 복사(대입) 된다.
2. 메소드 add의 괄호{} 안에 있는 문장들이 순서대로 수행된다.
3. 메소드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메소드(main 메소드)로 되돌아와서 이후의 문장들을 실행한다.

## return문

- return문 - 실행중인 메소드를 종료하고 호출한 곳으로 되돌아간다.

```java
void printGugudan(int dan) {
	if(!(2 <= dan && dan <= 9))
		return; // dan의 값이 2~9가 아닌 경우, 호출한 곳으로 그냥 되돌아 간다.

	for(int i = 1; i <= 9; i++) {
		System.out.printf("%d * %d = %d%n", dan, i, dan * i);
	}
	return; 반환타입이 void이므로 생략 가능. 컴파일러가 자동 추가
```

- 반환타입이 void가 아닌 경우, 반드시 return문 필요

```java
int multiply(int x, int y) {
	int result = x * y;
	return result; // 반환 타입이 void가 아니므로 생략 불가
}

int max(int a, int b) {
	if(a > b)
		return a; // 조건식이 참일 때만 실행되므로 return문이 없다는 에러가 발생

	// 아래처럼 작성해줘야 함.
	// if(a > b)
	//     return a; // 조건식이 참일 때 실행.
	// else
	//     return b; // 조건식이 거짓일 때 실행
}

```

## 반환값

- 메소드의 반환타입이 void가 아닐 때, 반드시 반환 값을 써줘야 한다. 이 반환 값은 반환타입과 타입이 일치해야한다.(자동형변환 가능)

## 호출 스택(call stack)

- 스택(stack) : 밑이 막힌 상자. 위에 차곡차곡 쌓인다. 스택에 넣을 때는 순서대로만 넣을 수 있고, 뺄 때도 위에서부터 순서대로 넣을 수 있다.
- 호출 스택 : 메소드 수행에 필요한 메모리가 제공되는 공간. 메소드가 호출되면 호출 스택에 메모리 할당, 종료되면 해제. 아래있는 메소드가 위의 메소드를 호출하게 됨. 맨 위의 메소드 하나만 실행 중, 나머지는 대기중.

1. 맨 처음에는 스택이 비어있다.
2. main 메소드가 호출되면 스택에 main 메소드가 쌓인다.
3. main 메소드가 println 메소드를 호출하면 main 메소드는 대기 상태가 되고, println 메소드가 위에 쌓이고 실행 상태가 된다.
4. println 메소드 실행 완료되면, 스택에서 사라진다. 메모리를 반환하고 종료. 그리고 자신을 호출했던 main 메소드로 돌아간다. 대기상태에 있던 main 메소드가 실행 상태가 된다.
5. 더 이상 실행할 문장이 없으면 main 메소드 종료되고, 프로그램이 종료된다.

## 기본형 매개변수

- 기본형 매개변수 - 변수의 값을 읽기만 할 수 있다.(read only)
- 참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다.(read & write)

## 참조형 반환 타입

## static 메소드와 인스턴스 메소드

- 인스턴스 메소드
    - 인스턴스 생성 후, ‘참조변수.메소드이름()’으로 호출
    - 인스턴스 멤버(iv, im)와 관련된 작업을 하는 메소드
    - 메소드 내에서 인스턴스 변수(iv) 사용 가능
- static 메소드(클래스 메소드)
    - 객체생성 없이 ‘클래스이름.메소드이름()’으로 호출
    - 인스턴스 멤버(iv, im)와 관련없는 작업을 하는 메소드
    - 메소드 내에서 인스턴스 변수(iv) 사용 불가
    
- 결국 static 메소드와 인스턴스 메소드의 차이는 인스턴스 변수(iv) 사용 여부의 차이

## static을 언제 붙여야 할까?
- 속성(멤버 변수) 중에서 공통 속성에 static을 붙인다.
- 인스턴스 멤버(iv, im)을 사용하지 않는 메소드에 static을 붙인다.

## 메소드 간의 호출과 참조

- static 메소드는 인스턴스 변수(iv)를 사용할 수 없다.
    - 인스턴스 변수는 객체 생성 후 사용 가능. 클래스 변수는 언제나 사용 가능.
    - 인스턴스 메소드는 객체 생성 후 호출 가능 - 객체가 생성이 됐으니까 인스턴스 변수 사용 가능. 클래스 변수도 사용 가능.
    - 스태틱 메소드는 인스턴스 변수를 사용할 수 없다. 클래스 변수는 사용할 수 있다.

- static 메소드는 인스턴스 메소드(im)를 호출할 수 없다.
    - 인스턴스 메소드는 객체를 생성하고 사용하니까 다른 인스턴스 메소드를 호출할 수 있다. static 메소드도 호출 가능.
    - static 메소드에서는 인스턴스 메소드를 호출할 수 없다.
    - static 메소드는 호출할 수 있다.
    

## 오버로딩(overloading)

- 한 클래스 안에 같은 이름의 메소드 여러 개를 정의하는 것
- 오버로딩이 성립하기 위한 조건
    1. 메소드 이름이 같아야 한다.
    2. 매개변수의 개수 또는 타입이 달라야 한다.
    3. 반환 타입은 영향 없다.

- 오버로딩의 올바른 예 - 매개변수는 다르지만 같은 의미의 기능 수행

## 생성자(constructor)

- 인스턴스가 생성될 때마다 호출되는 ‘인스턴스 초기화 메소드’
- 인스턴스 생성 시 수행할 작업(iv 초기화)에 사용
- 생성자는 기본적으로 메소드

- 생성자의 이름은 클래스 이름과 같아야 한다.
- 리턴값이 없다.(void 안붙임)
- 모든 클래스는 반드시 생성자를 가져야 한다. - 기본 생성자는 컴파일러가 추가해준다.

```java
클래스이름(타입 변수명, 타입 변수명, ...) {
	// 인스턴스 생성 시 수행될 코드,
	// 주로 인스턴스 변수의 초기화 코드를 적는다.
}

class Card {
	...
	Card() { // 매개 변수 없는 생성자.
		// 인스턴스 초기화 작업
	}

	Card(String kind, int number) { // 매개변수 있는 생성자
		// 인스턴스 초기화 작업
	}
}
```

- Card 라는 이름을 같게 해서 생성자 오버로딩함.