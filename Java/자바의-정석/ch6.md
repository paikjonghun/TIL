## 객체지향 언어

80년대 초반 소프트웨어의 위기 - 빠른 변화를 못 쫓아감.

해결책으로 객체지향 언어를 도입(절차적 → 객체지향)

코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거. - 객체 지향 언어의 장점

객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙) - 기본적인 언어에서 규칙들이 추가된 것.

객체 지향 언어(Object Oriented Programming)의 핵심 개념

1. 캡슐화
2. 상속
3. 추상화
4. 다형성

- 객체지향 개념은 어떻게 공부해야 하는가?
    - 객체지향 개념과 규칙들을 일단 외우기!
    - 실습 위주로 공부하기

## 클래스와 객체

- 클래스의 정의
    - 클래스란 객체를 정의해 놓은 것
- 클래스의 용도
    - 클래스는 객체를 생성하는데 사용

- 객체의 정의
    - 실제로 존재하는 것. 사물 또는 개념
- 객체의 용도
    - 객체가 가지고 있는 기능과 속성에 따라 다름

| 클래스 | 객체 |
| --- | --- |
| 제품 설계도 | 제품 |
| TV 설계도 | TV |
| 붕어빵 기계 | 붕어빵 |

## 객체의 구성요소 - 속성과 기능

- 객체 = 속성(변수) + 기능(메소드)
    - 속성 : 크기, 길이, 높이, 색상, 볼륨, 채널 등
    - 기능 : 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등
- 속성은 변수로, 기능은 메소드로 정의해서 하나의 클래스를 만듦.

## 객체와 인스턴스

- 객체 : 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스 : 특정 클래스로부터 생성된 객체(예:TV인스턴스)

- 인스턴스화
    - 클래스(설계도) → 인스턴스(객체)(제품)

## 클래스와 객체

- 클래스(설계도)가 왜 필요한가? - 객체(제품)를 생성하기 위해서
- 객체(제품)가 왜 필요한가? - 객체(제품)을 사용하기 위해서
- 객체를 사용한다는 것은? - 객체가 가진 속성과 기능을 사용하는 것

## 하나의 소스파일에 여러 클래스 작성

- 가능하다면 하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직하다!

- public class가 있는 경우, 소스파일의 이름은 반드시 public class의 이름과 일치해야 한다.
- public class가 하나도 없는 경우, 소스파일의 이름은 ‘Hello2.java’, ‘Hello3.java’ 둘 다 가능하다.

- 잘못된 작성
    - 하나의 소스파일에 둘 이상의 public class가 존재하면 안된다. 각 클래스를 별도의 소스파일에 나눠서 저장하거나 둘 중의 한 클래스에 public을 붙이지 않아야 한다.
    - 소스파일의 이름이 public class와 이름이 일치하지 않는 경우, 소스파일의 이름을 수정해야 한다.
    - 자바는 대소문자를 구분하므로 소스파일의 이름과 public class의 이름의 대소문자까지 일치해야한다.

## 객체의 생성과 사용

1. 객체의 생성

```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조 변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t; // Tv클래스 타입의 참조변수 t를 선언
t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```

1. 객체의 사용

```java
t.channel = 7; // Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
t.channelDown(); // Tv인스턴스의 메소드 channelDown()을 호출한다.
System.out.println("현재 채널은 " + t.channel + " 입니다.");
```

1. 클래스(설계도) 작성
2. 객체(제품) 생성
3. 객체(제품) 사용 - 변수와 메소드

- 하나의 인스턴스를 여러 개의 참조변수가 가리키는 경우는 가능
- 여러 인스턴스를 하나의 참조변수가 가리키는 경우는 불가능

## 객체 배열

- 객체 배열 == 참조변수 배열

```java
Tv tv1, tv2, tv3; // 이것을 객체 배열로 표현 가능

Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

// 객체 배열 생성 방법 2
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
```

## 클래스의 정의(1)

- 클래스
    1. 설계도
    2. 데이터 + 함수(데이터와 함수의 결합)
    3. 사용자 정의 타입

- 클래스 == 데이터 + 함수

1. 변수 - 하나의 데이터를 저장할 수 있는 공간
2. 배열 - 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체 - 서로 관련된 여러 데이터(종류 관계 X)를 하나로 저장할 수 있는 공간
4. 클래스 - 데이터와 함수의 결합(구조체 + 함수)

## 클래스 정의(2)

- 사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.

```java
// 시간을 일일이 만들 필요 없이
int hour1, hour2, hour3
int minute1, minute2, minute3
int second1, second2, second3

// 클래스로 타입을 만들면 사용이 더 편리하다.
class Time {
	int hour;
	int minute;
	int second;
}

// 시, 분, 초가 한번에 묶여서 더 편리하다.
Time t1 = new Time();
Time t2 = new Time();
Time t3 = new Time();
```

## 선언 위치에 따른 변수의 종류

```java
class Variables {
	int iv; // 인스턴스 변수
	static int cv; // 클래스 변수(static 변수, 공유 변수)
	
	void method() {
		int lv = 0; // 지역 변수
	}
}
```

- 클래스의 영역
    1. 클래스 영역(클래스 안쪽 전체 영역 - 클래스 시작부터 끝까지) - iv, cv
        1. 클래스 영역에는 선언문만 작성 가능 - 변수 선언, 메소드 선언(메소드 정의)
        2. 선언문의 순서는 상관 없다. 일반적으로 변수 선언을 먼저 한다.
    2. 메소드 영역(메소드 안쪽 영역 - 메소드 시작부터 끝까지) - lv

| 변수의 종류 | 선언 위치 | 생성시기 |
| --- | --- | --- |
| 클래스 변수(class variable) | 클래스 영역 | 클래스가 메모리에 올라갈 때 (따라서 cv는 객체 생성이 필요 없다. 아무 때나 사용 가능.) |
| 인스턴스 변수(instance variable) | 클래스 영역 | 인스턴스가 생성되었을 때(객체 생성을 해야 사용할 수 있다.) |
| 지역 변수(local variable) | 클래스 영역 이외의 영역(메소드 생성자, 초기화 블럭 내부) | 변수 선언문이 수행되었을 때 (메소드 종료시 자동 제거) |

## 클래스 변수와 인스턴스 변수

- 개별 속성을 가져야 하는 것은 - 인스턴스 변수
- 공통 속성을 가져야 하는 것은 - 클래스 변수

```java
class Card {
	String kind; // 무늬
	int number; // 숫자

	static int width = 100; // 폭
	static int height = 250; // 높이
}

Card c = new Card();
c.kind = "HEART";
c.number = 5;
c.width = 200; // -> Card.width = 200;
c.height = 300; // -> Card.height = 300; cv는 클래스 이름을 붙이는 것이 좋음.
								// cv는 참조변수가 아니기 때문.
```

## 메소드란?

1. 문장들을 {}블럭으로 묶어놓은 것.
    1. 작업 단위로 문장들을 묶어서 이름 붙인 것.
2. 값(입력)을 받아서 처리하고, 결과를 반환(출력)할 수 있음.
    1. 입력은 0~n개 가능. 출력은 0~1개
    2. 출력을 여러개 해야하면 배열이나 객체로 출력.

- 메소드의 장점
    - 코드의 중복을 줄일 수 있다.
    - 코드의 관리가 쉽다.
    - 코드를 재사용할 수 있다.
    - 코드가 간결해서 이해하기 쉬워진다.

- 메소드의 작성
    - 반복적으로 수행되는 여러 문장을 메소드로 작성
    - 하나의 메소드는 한 가지 기능만 수행하도록 작성

- 메소드 = 선언부 + 구현부
    
    ```java
    반환타입 메소드이름(타입 변수명, 타입 변수명, ...) // 선언부
    { // 구현부
    
    	// 메소드 호출 시 수행될 코드
    
    }
    ```
    
- 지역 변수(lv) : 메소드 내에 선언된 변수
    - 매개변수도 지역변수. 메소드 내에서만 사용 가능.