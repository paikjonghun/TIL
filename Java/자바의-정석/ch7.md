# ch7. 객체지향개념 2

## 7-1. 상속(Inheritance)

- 기존의 클래스로 새로운 클래스를 작성하는 것.(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것
    
    ```java
    class 자식클래스 extends 부모클래스 {
    	/// ...
    }
    
    class Parent {}
    class Child extends Parent { // 상속관계
    	// ...
    }
    ```
    
- 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다.)
- 자손의 변경은 조상에 영향을 미치지 않는다.

## 7-3. 포함 관계

- 포함(composite)이란?
    - 클래스의 멤버로 참조변수를 선언하는 것
    - 작은 단위의 클래스를 만들고, 이들을 조합해서 클래스를 만든다.

## 7-4. 클래스 간의 관계 결정하기

- 상속관계 : ‘~은 ~이다. (is-a)’
- 포함관계 : ‘~은 ~을 가지고 있다. (has-a)’
- 포함
    
    ```java
    class Circle {
    	Point c = new Point();
    	int r;
    }
    ```
    
- 상속
    
    ```java
    class Circle extends Point {
    	int r;
    }
    ```
    
    - 원(Circle)은 점(Point)이다. - Circle is a Point.
    - 원(Circle)은 점(Point)을 가지고 있다. - Circle has a Point.

## 7-5. 단일 상속(Single Inheritance)

- Java는 단일상속만을 허용한다.(C++은 다중상속 허용)
    
    ```java
    class TvDVD extends Tv, DVD { // 에러. 조상은 하나만 허용된다.
    	// ...
    }
    ```
    
    - 다중 상속의 문제점
        - 부모가 두 개일 때, 이름이 똑같은 메소드가 있고 내용이 다르면, 어느 것을 상속 받아야할지 충돌 문제가 생긴다. - 충돌 위험이 높다.
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.

## 7-6. Object 클래스 - 모든 클래스의 조상

- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.
- 모든 클래스는 Object클래스에 정의된 11개의 메소드를 상속받는다. (toString(), equals(Object obj), hashCode(), ...)
    - toString() : 클래스 이름과 객체 주소값을 문자열로 돌려줌.

## 7-7. 오버라이딩(overriding)

- 상속받은 조상의 메소드를 자신에 맞게 변경하는 것 - 정확하게는 메소드 오버라이딩. override는 덮어쓰다.

```java
class Point {
	int x;
	int y;

	String getLocation() {
		return "x :" + x + ", y :" + y;
	}
}

class Point3D extends Point {
	int z;
	
	String getLocation() {
		retunr "x :" + x + ", y :" + y + ", z :" + z;
	}
}
```

오버라이딩 - 조상의 메소드를 고친 것. 선언부는 못 바꿈. 내용(구현부. {})만 변경 가능.

## 7-8. 오버라이딩의 조건

1. 선언부가 조상 클래스의 메소드와 일치해야 한다.(반환타입, 메소드이름, 매개변수목록 일치해야함)
2. 접근 제어자를 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다.(public, protected, private, default)
3. 예외는 조상 클래스의 메소드보다 많이 선언할 수 없다.

## 7-9. 오버로딩 vs. 오버라이딩

- 근본적으로 둘은 상관이 없다.
- 오버로딩(overloading) - 기존에 없는 새로운 메소드를 정의하는 것(new). 상속과 관계 없다.
- 오버라이딩(overriding) - 상속받은 메소드의 내용을 변경하는 것(change, modify). 상속과 관계 있다.

## 7-10. 참조변수 super

- 객체 자신을 가리키는 참조변수. 인스턴스 메소드(생성자)내에만 존재. this와 비슷하다.(this도 인스턴스 메소드 안에서만 사용할 수 있다.) static 메소드 내에서 사용 불가.
- 조상의 멤버를 자신의 멤버와 구별할 때 사용(this는 lv와 iv 구별에 사용)

## 7-11. super() - 조상의 생성자.

- 조상의 생성자를 호출할 때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화
- 생성자의 첫 줄에 반드시 생성자를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입

## 7-12. 패키지(package)

- 서로 관련된 클래스의 묶음
    - Java8 기준 약 4000개의 클래스가 있음. 묶어서 관리하는 게 좋다.
- 클래스는 클래스 파일(*.class), 패키지는 폴더. 하위 패키지는 하위 폴더.
- 클래스의 실제 이름(full name)은 패키지를 포함.(java.lang.String)
- rt.jar(런타임 - 실행할 때, 실행중을 의미)는 클래스들을 압축한 파일(JDK설치경로\jre\lib에 위치)
    - rt.jar - 자바 프로그램이 실행하는데 필요한 클래스 파일들을 묶어놓은 것.
    - jar - 클래스 파일 묶어놓은 것. 압축파일. - jar.exe로 압축해제 가능. zip과 똑같음.
    - Java 9 부터 rt.jar 파일 없어짐. module의 개념이 들어오면서 잘게 쪼개짐.

## 7-13 패키지의 선언

- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으면 이름없는(unnamed, default package) 패키지에 속하게 된다.

## 7-14. 클래스 패스(classpath)

- 클래스 파일(*.class)의 위치를 알려주는 경로(path)
- 환경 변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용
    - classpath(환경변수)에 패키지의 루트를 등록해줘야 함

## 7-15. import문

- import문을 사용하면 클래스를 사용할 때 패키지 이름을 생략할 수 있다.
- 컴파일러에게 클래스가 속한 패키지를 알려준다.
- java.lang 패키지의 클래스는 import하지 않고도 사용할 수 있다.(ex) String, Object, System, Thread)
- import문을 선언하는 방법은 다음과 같다.
    
    ```java
    import 패키지명.클래스명;
    	// 또는
    import 패키지명.*; // *은 모든 클래스
    ```
    
- import문은 패키지문과 클래스 선언의 사이에 선언한다.
- import문은 컴파일 시에 처리되므로 프로그램의 성능에 영향이 없다! 임포트문은 컴파일러를 위한 문장이기 때문에 컴파일 되고 나면 상관없다.
- 다음의 두 코드는 서로 의미가 다르다.
    
    ```java
    import java.util.*;
    import java.text.*;
    
    // 위와 아래는 다르다.
    
    import java.*; // java 패키지의 모든 클래스(패키지는 포함 안됨)
    ```
    
- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지 명을 붙여줘야 한다.

## 7-16. static import문

- static 멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.
    
    ```java
    import static java.lang.Integer.*; // Integer 클래스의 모든 static 메소드
    import static java.lang.Math.random; // Math.random()만. 괄호 안 붙임.
    import static java.lang.System.out; // System.out을 out만으로 참조 가능
    
    out.println(random());
    ```
    

## 7-17. 제어자(modifier)

- 클래스와 클래스의 멤버(멤버 변수, 메소드)에 부가적인 의미 부여
    - 접근 제어자 : public, protected, (default), private - 하나의 대상에 4개 중 1개만 붙일 수 있다.
    - 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp

- 하나의 대상에 여러 제어자를 같이 사용 가능 (접근 제어자는 하나만)

## 7-18. static - 클래스의, 공통적인

- static
    - 멤버변수
        - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
        - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
        - 클래스가 메모리에 로드될 때 생성된다.
    - 메소드
        - 인스턴스를 생성하지 않고도 호출이 가능한 static 메소드가 된다.
        - static 메소드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.

## 7-19. final - 마지막의, 변경될 수 없는

- final
    - 클래스
        - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
        - 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다. (상속 계층도의 제일 마지막 클래스라는 뜻이기도 하다. 대표적인 final 클래스는 String(보안 문제 때문), Math(전부 static 메소드 라서))
    - 메소드
        - 변경될 수 없는 메소드. final로 지정된 메소드는 오버라이딩(조상 메소드를 덮어 쓰는 것)을 통해 재정의될 수 없다.
    - 멤버변수 + 지역변수
        - 변수 앞에 fianl이 붙으면, 값을 변경할 수 없는 상수가 된다.

## 7-20. abstract - 추상의, 미완성의

- abstract
    - 클래스
        - 클래스 내에 추상 메소드가 선언되어 있음을 의미한다.
    - 메소드
        - 선언부만 작성하고 구현부는 작성하지 않은 추상 메소드임을 알린다.
    
    ```java
    abstract class AbstractTest { // 추상 클래스(추상 메소드를 포함한 클래스)
    	abstract void move(); // 추상 메소드(구현부가 없는 메소드) - 미완성 메소드
    }
    
    AbstractTest a = new AbstractTest(); // 에러. 추상 클래스의 인스턴스 생성불가. 추상 클래스는 미완성 설계도이기 때문.
    ```
    
- 추상 클래스를 상속 받아서 완전한 클래스를 만든 후에 객체 생성 가능. 추상 클래스 자체는 미완성이기 때문에 객체를 만들 수 없음. 추상 클래스의 반대말 = 구상 클래스.

## 7-21. 접근 제어자(access modifier)

- private - 같은 클래스 내에서만 접근이 가능하다.
- (default) - 같은 패키지 내에서만 접근이 가능하다. 아무것도 안 붙인 것이 default.
- protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
- public - 접근 제한이 전혀 없다.

- 접근 제어자, 클래스 앞에 붙일 수 있는 것은 public 또는 (default)
- 멤버에는 접근 제어자 네 개 다 붙일 수 있다.

## 7-22. 캡슐화와 접근 제어자

- 접근 제어자를 사용하는 이유!
    - 외부로부터 데이터를 보호하기 위해서(캡슐화) - 접근 제어자를 사용해 직접 접근을 막고, 메소드를 사용해 간접 접근을 허용한다.
    - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서.

## 7-23. 다형성(polymorphism)

- 여러가지 형태를 가질 수 있는 능력
- **조상 타입 참조 변수로 자손 타입 객체를 다루는 것!!!**
    
    ```java
    Tv t = new SmartTv(); // 타입 불일치 OK!!!
    ```
    
    - 타입 불일치의 장점 때문에 다형성이 중요함. 굉장한 유연함을 준다. 불일치해도 된다~

- 객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?
    - 스마트 티비를 스마트 티비 리모콘으로 다루면 모든 버튼을 다루지만, 조상 타입의 참조 변수로 스마트 티비 객체를 다루면 조상 타입의 참조 변수가 가지고 있는 버튼만 다룬다.
    
- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
    
    ```java
    Tv t = new SmartTv(); // Ok. 허용.
    SmartTv s = new Tv(); // 에러. 허용 안 됨 .
    ```
    

## 7-24. 참조변수의 형변환

- 사용할 수 있는 멤버의 개수를 조절하는 것!
    - 기본형의 형변환은 값이 바뀐다.
    - 참조변수의 형변화는 멤버의 갯수를 조절하는 것임
- 조상 자손 관계의 참조변수는 서로 형변환 가능!

```java
class Car {}
class FireEngine extends Car {}
class Ambulance extends Car {}

FireEngine f = new FireEngine(); // OK. 조상인 Car 타입으로 형변환(생략가능)
FireEngine f2 = (FireEngine) c; // OK. 자손인 FireEngine타입으로 형변환(생략불가)
Ambulance a = (Ambulance)f; // 에러. 상속관계가 아닌 클래스 간의 형변환 불가
```

## 7-26. instanceof 연산자

- 참조변수의 형변환(조상↔자손) 가능여부 확인에 사용. 가능하면 true 반환.
- 형변환 전에 반드시 instanceof로 확인해야 함!!!
    - instanceof는 상속계층도에서 조상들도 참이 나옴. instanceof가 참이 나오면 형변환이 가능하다는 이야기.

- 참조변수의 형변환은 왜 하는가?
    - 참조변수(리모콘)을 변경함으로써 사용할 수 있는 멤버의 갯수를 조절하기 위해서
- instanceof 연산자는 언제 사용하는가?
    - 참조변수를 형변환하기 전에 형변환 가능여부를 확인할 때.

## 7-27. 매개변수의 다형성

- 다형성의 장점
    1. 다형적 매개변수
    2. 하나의 배열로 여러 종류 객체 다루기

- 다형성
    1. `Tv t = new SmartTv();`
    2. 참조변수의 형변환 - 리모콘 바꾸기 (사용할 수 있는 멤버 개수 조절)
    3. instanceof 연산자 - 형변환 가능여부 체크

- 참조형 매개변수는 메소드 호출 시, 자신과 같은 타입 또는 자손 타입의 인스턴스를 넘겨줄 수 있다.

## 7-29. 여러 종류의 객체를 배열로 다루기

- 조상타입의 배열에 자손들의 객체를 담을 수 있다.

```java
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

## 7-31. 추상 클래스(abstract class)

- 미완성(부족한) 설계도. 미완성 메소드를 갖고 있는 클래스.

```java
abstract class Player { // 추상클래스(미완성 클래스)
	abstract void play(int pos); // 추상메소드(몸통{}이 없는 미완성 메소드)
	abstract void stop(); // 추상메소드
}
```

- 추상메소드는 몸통이 없는 대신에 abstract라는 키워드를 붙인다. 추상메소드를 가지고 있는 클래스를 추상클래스라고 말한다. 추상 클래스도 앞에 abstract를 붙여야 한다.
- 다른 클래스 작성에 도움을 주기 위한 것. 인스턴스 생성 불가!!! 추상 클래스의 인스턴스 생성 불가!!!
- 상속을 통해 추상 메소드를 완성해야 인스턴스 생성 가능!!!!
    
    ```java
    class AudioPlayer extends Player {
    	void play(int pos) { /* 내용 생략 */ } // 추상메소드를 구현
    	void stop() { /* 내용 생략 */ } // 추상메소드를 구현
    }
    
    AudioPlayer ap = new AudioPlayer(); // OK.
    ```
    
    - 추상 메소드의 몸통을 만들어 주는 것을 구현이라고 함.
    - AudioPlayer는 완성된 클래스기 때문에 객체 생성 가능
    - AudioPlayer 타입 대신에 Player 타입 가능. 추상 메소드가 호출되는 것이 아니라 자손 클래스의 오버라이딩 된 메소드가 실행됨.

## 7-32. 추상 메소드(abstract method)

- 미완성 메소드. 구현부(몸통, {})가 없는 메소드
    
    ```java
    abstract 리턴타입 메소드이름(); // 추상 메소드. 
    ```
    
- 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 추상 메소드를 만든다.
- 추상 메소드 호출 가능(호출할 때는 선언부만 필요)

## 7-34. 추상클래스의 작성

- 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.
- 추상화(불명확) ↔ 구체화(명확, 구체적)
    - 추상화된 코드는 구체화된 코드보다 유연하다. 변경에 유리하다.
    
    ```java
    GregorianCalendar cal = new GregorianCalendar(); // 구체적
    Calendar Cal = Calendar.getInstance(); // 추상적
    ```
    

## 7-35. 인터페이스(interface)

- 추상 메소드의 집합 - 프로그래밍 관점에서의 인터페이스에 대한 설명
- 구현된 것이 전혀 없는 설계도. 껍데기(모든 멤버가 public)

```java
interface 인터페이스이름 {
	public static final 타입 상수이름 = 값; // 상수는 핵심은 아니다. 변수를 가질 수 없다.
	public abstract 메소드이름(매개변수목록); // 추상메소드
}
```

- 모든 인터페이스의 멤버는 public 이다.
- 인터페이스의 모든 메소드는 항상 public, abstract라서 생략 가능하다.
- 상수도 항상 public, static, final이라서 일부 또는 전부를 생략 가능하다.

## 7-36. 인터페이스의 상속

- 인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상 아님)
- 다중 상속(조상이 여러개)이 가능(추상메소드는 충돌해도 문제 없음) - 선언부가 다르면 둘다 상속받으면 그만인데, 선언부가 같고 내용{}이 다르면 어느 쪽을 상속받을지 결정할 수 없다

## 7-37. 인터페이스의 구현

- 인터페이스(미완성 설계도)의 구현 → 인터페이스에 정의된 추상 메소드를 완성하는 것.

```java
class 클래스이름 implements 인터페이스이름 {
	// 인터페이스에 정의된 추상메소드를 모두 구현해야 한다.
}
```

- 구현은 몸통{}을 완성하는 것
- 일부만 구현하는 경우, 클래스 앞에 abstract를 붙여야 함.
- 인터페이스를 구현한다는 것은 추상 클래스를 구현하는 것과 동일하다. implements 키워드만 다르다.

Q. 인터페이스란?

A. 추상 메소드의 집합. (상수, static 메소드, default 메소드가 추가됨 JDK 1.8부터 추가됨. 하지만 인터페이스의 핵심은 아니다! 기능적으로 보완하려고 들어간 것임.)

Q. 인터페이스의 구현이란?

A. 인터페이스의 추상 메소드 몸통{} 만들기(미완성 설계도 완성하기)

Q. 추상 클래스와 인터페이스의 공통점은?

A. 추상 메소드를 가지고 있다.(미완성 설계도)

Q. 추상 클래스와 인터페이스의 차이점은?

A. 인터페이스는 iv를 가질 수 없다.

## 7-38. 인터페이스를 이용한 다형성

- 인터페이스도 구현 클래스의 부모! (엄밀히 말하면 부모는 아니다. 클래스가 아니니까)

```java
class Fighter extends Unit implements Fightable {
	public void move(int x, int y) { /* 내용 생략 */ }
	public void attack(Fightable f) { /* 내용 생략 */ }
}

Unit u = new Fighter();
Fightable f = new Fighter();
```

- 인터페이스는 추상메소드라 몸통이 없어서 선언부가 충돌해도 상속 가능하다.
- 인터페이스 타입 매개변수는 인터페이스 구현한 클래스의 객체만 가능!
- 인터페이스를 메소드의 리턴타입으로 지정할 수 있다.
    - 인터페이스를 구현한 클래스의 인스턴스를 반환

## 7-39. 인터페이스의 장점

- 두 대상(객체) 간의 ‘연결, 대화, 소통'을 돕는 ‘중간 역할'을 한다.
- 선언(설계)와 구현을 분리시킬 수 있게 한다. - 변경에 유리하다. 유연한 코드가 된다.
- 인터페이스 덕분에 B가 변경되어도 A는 안바꿀 수 있게 된다.(느슨한 결합)
- 개발 시간을 단축할 수 있다.
- 변경에 유리한 유연한 설계가 가능하다.
- 표준화가 가능하다.(JDBC)
- 서로 관계없는 클래스들을 관계를 맺어줄 수 있다.

## 7-40. 디폴트 메소드와 static 메소드

- 인터페이스에 디폴트 메소드, static 메소드 추가 가능. (JDK1.8부터)
- 인터페이스에 새로운 메소드(추상 메소드)를 추가하기 어려움. → 해결책 : 디폴트 메소드(default method)
- 디폴트 메소드는 인스턴스 메소드(인터페이스 원칙 위반)
- 디폴트 메소드가 기존의 메소드와 충돌할 때의 해결책
    1. 여러 인터페이스의 디폴트 메소드 간의 충돌
        1. 인터페이스를 구현한 클래스에서 디폴트 메소드를 오버라이딩해야 한다.
    2. 디폴트 메소드와 조상 클래스의 메소드 간의 충돌
        1. 조상 클래스의 메소드가 상속되고, 디폴트 메소드는 무시된다.

## 7-42. 내부 클래스(inner class)

- 내부 클래스 : 클래스 안의 클래스
- 내부 클래스의 장점
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
    - 코드의 복잡성을 줄일 수 있다.(캡슐화)

## 7-43, 44. 내부 클래스의 종류와 특징

- 내부 클래스의 종류와 유효범위(scope)는 변수와 동일
    - 인스턴스 내부 클래스 = iv
    - 스태틱 내부 클래스  = cv
    - 지역 내부 클래스 = lv
    - 익명 클래스 - 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)

## 7-45. 내부 클래스의 제어자와 접근성

- 내부 클래스의 제어자는 변수에 사용 가능한 제어자와 동일
    - 원래 클래스에는 접근 제어자 두 개만 가능했는데, 내부 클래스는 변수에 사용 가능한 제어자(private, protected)와 똑같이 쓸 수 있다.

## 7-51. 익명 클래스(anonymous class)

- 익명 클래스 : 이름이 없는 일회용 클래스. 정의와 생성을 동시에.

```java
new 조상클래스이름() {
	// 멤버 선언
}

// 또는

new 구현인터페이스이름() {
	// 멤버 선언
}

```

- 클래스의 정의와 객체 생성을 동시에 하기 때문에 만들고 그냥 끝임.