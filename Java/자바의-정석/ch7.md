# ch7. 객체지향개념 2

## 7-1. 상속(Inheritance)

- 기존의 클래스로 새로운 클래스를 작성하는 것.(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것
    
    ```java
    class 자식클래스 extends 부모클래스 {
    	/// ...
    }
    
    class Parent {}
    class Child extends Parent { // 상속관계
    	// ...
    }
    ```
    
- 자손은 조상의 모든 멤버를 상속받는다.(생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다.)
- 자손의 변경은 조상에 영향을 미치지 않는다.

## 7-3. 포함 관계

- 포함(composite)이란?
    - 클래스의 멤버로 참조변수를 선언하는 것
    - 작은 단위의 클래스를 만들고, 이들을 조합해서 클래스를 만든다.

## 7-4. 클래스 간의 관계 결정하기

- 상속관계 : ‘~은 ~이다. (is-a)’
- 포함관계 : ‘~은 ~을 가지고 있다. (has-a)’
- 포함
    
    ```java
    class Circle {
    	Point c = new Point();
    	int r;
    }
    ```
    
- 상속
    
    ```java
    class Circle extends Point {
    	int r;
    }
    ```
    
    - 원(Circle)은 점(Point)이다. - Circle is a Point.
    - 원(Circle)은 점(Point)을 가지고 있다. - Circle has a Point.

## 7-5. 단일 상속(Single Inheritance)

- Java는 단일상속만을 허용한다.(C++은 다중상속 허용)
    
    ```java
    class TvDVD extends Tv, DVD { // 에러. 조상은 하나만 허용된다.
    	// ...
    }
    ```
    
    - 다중 상속의 문제점
        - 부모가 두 개일 때, 이름이 똑같은 메소드가 있고 내용이 다르면, 어느 것을 상속 받아야할지 충돌 문제가 생긴다. - 충돌 위험이 높다.
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.

## 7-6. Object 클래스 - 모든 클래스의 조상

- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.
- 모든 클래스는 Object클래스에 정의된 11개의 메소드를 상속받는다. (toString(), equals(Object obj), hashCode(), ...)
    - toString() : 클래스 이름과 객체 주소값을 문자열로 돌려줌.

## 7-7. 오버라이딩(overriding)

- 상속받은 조상의 메소드를 자신에 맞게 변경하는 것 - 정확하게는 메소드 오버라이딩. override는 덮어쓰다.

```java
class Point {
	int x;
	int y;

	String getLocation() {
		return "x :" + x + ", y :" + y;
	}
}

class Point3D extends Point {
	int z;
	
	String getLocation() {
		retunr "x :" + x + ", y :" + y + ", z :" + z;
	}
}
```

오버라이딩 - 조상의 메소드를 고친 것. 선언부는 못 바꿈. 내용(구현부. {})만 변경 가능.

## 7-8. 오버라이딩의 조건

1. 선언부가 조상 클래스의 메소드와 일치해야 한다.(반환타입, 메소드이름, 매개변수목록 일치해야함)
2. 접근 제어자를 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다.(public, protected, private, default)
3. 예외는 조상 클래스의 메소드보다 많이 선언할 수 없다.

## 7-9. 오버로딩 vs. 오버라이딩

- 근본적으로 둘은 상관이 없다.
- 오버로딩(overloading) - 기존에 없는 새로운 메소드를 정의하는 것(new). 상속과 관계 없다.
- 오버라이딩(overriding) - 상속받은 메소드의 내용을 변경하는 것(change, modify). 상속과 관계 있다.

## 7-10. 참조변수 super

- 객체 자신을 가리키는 참조변수. 인스턴스 메소드(생성자)내에만 존재. this와 비슷하다.(this도 인스턴스 메소드 안에서만 사용할 수 있다.) static 메소드 내에서 사용 불가.
- 조상의 멤버를 자신의 멤버와 구별할 때 사용(this는 lv와 iv 구별에 사용)

## 7-11. super() - 조상의 생성자.

- 조상의 생성자를 호출할 때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화
- 생성자의 첫 줄에 반드시 생성자를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입

## 7-12. 패키지(package)

- 서로 관련된 클래스의 묶음
    - Java8 기준 약 4000개의 클래스가 있음. 묶어서 관리하는 게 좋다.
- 클래스는 클래스 파일(*.class), 패키지는 폴더. 하위 패키지는 하위 폴더.
- 클래스의 실제 이름(full name)은 패키지를 포함.(java.lang.String)
- rt.jar(런타임 - 실행할 때, 실행중을 의미)는 클래스들을 압축한 파일(JDK설치경로\jre\lib에 위치)
    - rt.jar - 자바 프로그램이 실행하는데 필요한 클래스 파일들을 묶어놓은 것.
    - jar - 클래스 파일 묶어놓은 것. 압축파일. - jar.exe로 압축해제 가능. zip과 똑같음.
    - Java 9 부터 rt.jar 파일 없어짐. module의 개념이 들어오면서 잘게 쪼개짐.

## 7-13 패키지의 선언

- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으면 이름없는(unnamed, default package) 패키지에 속하게 된다.

## 7-14. 클래스 패스(classpath)

- 클래스 파일(*.class)의 위치를 알려주는 경로(path)
- 환경 변수 classpath로 관리하며, 경로간의 구분자는 ‘;’를 사용
    - classpath(환경변수)에 패키지의 루트를 등록해줘야 함

## 7-15. import문

- import문을 사용하면 클래스를 사용할 때 패키지 이름을 생략할 수 있다.
- 컴파일러에게 클래스가 속한 패키지를 알려준다.