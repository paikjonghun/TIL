## 11-1. 컬렉션 프레임웍(collections framework)

- 컬렉션(collection) - 물건을 모아 놓은 것.
    - 여러 객체(데이터)를 모아 놓은 것을 의미
- 프레임웍(framework)
    - 표준화, 정형화된 체계적인 프로그래밍 방식
        - library - 도서관 - 책들을 모아놓음. 책은 다른 사람들이 만든 정보.
            - 오디오 라이브러리 - 웬만한건 이미 다 만들어놓음.
            - 통계 라이브러리
            - 그래픽 라이브러리
        - 프레임웍은 라이브러리(기능) + 프로그래밍 방식(프로그래밍을 어떻게 하라고 강제)
- 컬렉션 프레임웍(collections framework)
    - 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식
    - 컬렉션을 쉽고 편리하게 다룰 수 있는(저장, 삭제, 검색, 정렬) 다양한 클래스를 제공.
    - java.util패키지에 포함. JDK1.2부터 제공
- 컬렉션 클래스(collection class)
    - 다수의 데이터를 저장할 수 있는 클래스(ex. Vectior, ArrayList, HashSet)

## 11-2. 컬렉션 프레임웍(다수의 data를 다루기 위한 것)의 핵심 인터페이스

- **List** - 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. 예) 대기자 명단
- **Set** - 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다. 예) 양의 정수집합, 소수의 집합
- **Map** - 키와 값의 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.예) 우편번호, 지역번호(전화번호)

## 11-3. Collection 인터페이스의 메소드

- List - 순서O, 중복O
- Set - 순서X, 중복X
- Map - 순서X, 중복-키X, 값O

## 11-7. ArrayList

- ArrayList는 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일
- ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어있다.
- List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- 데이터의 저장공간으로 배열을 사용한다.(배열기반) List가 붙은 것들은 List 인터페이스를 구현했다는 뜻

## 11-8. ArrayList의 메소드

- 생성자
    - ArrayList()
    - ArrayList(Collection c)
    - ArrayList(int initialCapacity) - 배열의 길이를 넣어주는 것
- 추가하는 메소드
    - boolean add(Object o)
    - void add(int index, Object element)
    - boolean addAll(Collection c)
    - boolean addAll(int index, Collection c)
- 삭제하는 메소드
    - boolean remove(Object o)
    - Object remover(int index)
    - boolean removeAll(Collection c)
    - void clear() - 모든 객체 삭제
- 검색하는 메소드
    - int indexOf(Object o)
    - int lastIndexOf(Object o)
    - boolean contains(Object o) - 객체가 존재?
    - Object get(int index)
    - Object set(int index, Object element)
- 그 외
    - List subList(int fromindex, int toIndex)
    - Object[] toArray()
    - Object[] toAarray(Object[] a)
    - boolean isEmpty()
    - void trimToSize()
    - int size()

## 11-12. LinkedList - 배열의 장단점

- 장점 : 배열은 구조가 간단하고 데이터를 읽는데 걸리는 시간(접근시간, access time)이 짧다. 배열은 연속적이다.
- 단점 1 : 배열을 한번 생성하면 크기 변경할 수 없다.
    - 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야함. 저장할 공간 만드려면 더 큰 배열 생성, 복사, 참조 변경 해야함.
    - 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨.
- 단점 2 : 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
    - 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.
    - 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다.

## LinkedList - 배열의 단점을 보완

- 배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결(link)
    - 데이터의 삭제 : 단 한번의 참조변경만으로 가능.
    - 배열은 다 붙어있는 통과 같고, LinkedList는 기차와 같다. LinkedList가 변경에 유리하다.
    - 데이터의 추가 : 한번의 Node 객체 생성과 두 번의 참조변경만으로 가능

## LinkedList - 이중 연결 리스트

- Linked List - 연결 리스트. 데이터 접근성이 나쁨
- doubly linked list - 이중 연결리스트, 접근성 향상
- doubly circular linked list) - 이중 원형 연결리스트

## ArrayList vs. LinkedList - 성능 비교

1. 순차적으로 데이터를 추가/삭제 - ArrayList가 빠름
2. 비순차적으로 데이터를 추가/삭제 - LinkedList가 빠름
3. 접근시간(access time) - ArrayList가 빠름
    1. 인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기
- ArrayList는 배열기반(연속), LinkedList는 연결기반(불연속)의 자료구조
    - 자료구조 - 데이터를 어떤 식으로 정리해야하는지를 연구한 것.

## 11-15. 스택과 큐(Stack & Queue)

- 스택(Stack) : 밑이 막힌 상자. LIFO(Last In First Out)구조. 마지막에 저장된 것을 제일 먼저 꺼내게 된다.
    - 저장 - push, 추출 - pop
- 큐(Queue) : 줄 서기. FIFO(Firsrt In First Out)구조. 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다.
    - 저장 - offer, 추출 - poll

## 11-16. 스택과 큐(Stack & Queue)의 메소드

- 클래스가 있어서 Stack st = new Stack(); 으로 사용 가능
    - boolean empty() - Stack이 비어있는지 알려준다.
    - Object peek() - Stack의 맨 위에 저장된 객체를 반환. pop()과 달리 Stack에서 객체를 꺼내지는 않음.
    - Object pop() - Stack의 맨 위에 저장된 객체를 꺼낸다. (비었을 때는 EmptyStackException 발생)
    - Object push(Object item) - Stack에 객체를 저장한다.
    - int search(Object o) - Stack에서 주어진 객체를 찾아서 그 위치를 반환. 못 찾으면 -1을 반환. (배열과 달리 위치는 0이 아닌 1부터 시작)
- Queue의 메소드 - Queue는 인터페이스라 객체 생성 안됨.
    - boolean add(Object o) - 지정된 객체를 Queue에 추가한다. 성공하면 true를 반환. 저장공간이 부족하면 IllegalStateException발생
    - Object remove() - Queue에서 객체를 꺼내 반환. NoSuchElementException발생.
    - Object element() - 삭제없이 요소를 읽어온다. peek과 달리 Queue가 비었을 때 NoSuchElementException발생
    - boolean offer(Object o) - Queue에 객체를 저장. 성공하면 true, 실패하면 false를 반환. 예외 발생 x
    - Object poll() - Queue에서 객체를 꺼내서 반환. 비어있으면 null을 반환. 예외 발생 x
    - Object peek() - 삭제없이 요소를 읽어 온다. Queue가 비어있으면 null을 반환.

## 11-18. 인터페이스를 구현한 클래스 찾기

- Queue의 기능을 갖고 있는 객체를 쓰고 싶다면
    1. Queue를 직접 구현
    2. Queue를 구현한 클래스를 사용

- Java API에서 Queue 인터페이스를 찾아보면
    - All Known Implementing Classes - Queue를 구현한 클래스 목록
        - LinkedList가 있다.
        - Queue q = new LinkedList();

## 11-19. 스택과 큐(Stack & Queue)의 활용

스택의 활용 예 - 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로

큐의 활용 예 - 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer)

