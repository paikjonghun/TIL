## 형변환 연산자

- 형변환 - 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- (타입)피연산자
    - double d = 85.4;
    - int scroe = (int)d;

- int → char : `(char)65` → ‘A’
- char → int : `(int)’A’` → 65
- float → int : `(int)1.6f` → 1
- int → float : `(float)10` → 10.0f

## 자동 형변환

```java
float f = 1234; // int 타입의 값을 float 타입의 변수에 저장. 형변환이 생략된 것임.
float f = (float)1234; // 컴파일러가 이 형태로 자동으로 형변환. 
```

```java
int i = 3.14f; // 에러 발생. float 범위가 넓은데 작은 integer 범위에 넣으려고 하면 오류.
int i = (int)3.14f; // 값 손실이 발생할 수 있기 때문에 수동 형변환을 해야함.
```

1. byte → int
    
    ```java
    byte b = 10;
    int i = b; // 형변환 생략 가능. byte는 1byte. int는 4byte. 값손실 없으므로 자동 형변환.
    ```
    
2. int → byte
    
    ```java
    int i2 = 300;
    byte b2 = (byte)i2; // 형변환 생략 불가. 값손실 있을 수 있으므로 수동 형변환 해야 함.
    ```
    

- 형변환을 생략하면 컴파일러가 알아서 자동으로 형변환을 한다. 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 된다. 표현범위가 좁은 타입에서 넓은 타입으로 형변화는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.

- 예외적 상황
    
    ```java
    byte b = 100; // OK. byte타입의 범위(-128 ~ 127)의 값의 대입
    byte b = (byte)100; // OK. byte타입으로 자동 형변환하여 대입. 값 손실이 없기 때문에 가능.
    ```
    
    ```java
    int i = 100;
    byte b = i; // 에러. int타입을 byte타입에 대입. 변수라서 변수 안에 어떤 값이 있는지 컴파일러는 
    						// 알 수 없다. 수동 형변환을 해야함.
    byte b = (byte)i; // OK. bytexㅏ입으로 형변환하여 대입
    ```
    
    ```java
    byte b = 1000; // 에러. byte타입의 범위(-128 ~ 128)를 벗어난 값의 대입.
    								// 값 손실이 있기 때문에 자동 형변환이 안됨.
    byte b = (byte)1000; // OK. 그러나 값손실이 발생해서 변수 b에는 -24가 저장됨.
    ```