# ch6. 클래스

## 객체 지향 프로그래밍

키워드 : 클래스, 객체, new 연산자, 클래스 변수, 인스턴스, 클래스 멤버

핵심 포인트 : 객체의 개념과 객체의 상호작용에 대해 알아본다. 클래스로부터 객체를 생성하고 변수로 참조한다.

### 객체(Object)

- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지며 식별 가능한 것
- 속성(필드(field)) + 동작(메소드(method))로 구성
    - 사람
        - 속성 - 이름, 나이 → 필드
        - 동작 - 웃다, 먹다 → 메소드
    - 자동차
        - 속성 - 색깔, 속도 → 필드
        - 동작 - 달린다, 멈춘다 → 메소드

객체 모델링 - 현실 세계의 객체를 소프트웨어 객체로 설계하는 것. 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정.

### 객체의 상호작용

- 객체와 객체 간의 상호작용
    - 메소드를 통해 객체들이 상호작용
    - 메소드 호출 : 객체가 다른 객체의 기능을 이용하는 것

### 객체 간의 관계

- 집합 관계
    - 부품과 완성품의 관계
- 사용 관계
    - 객체 간의 상호작용
- 상속 관계
    - 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성

### 객체와 클래스

- 클래스 - 자바의 설계도
- 인스턴스 - 클래스로부터 만들어진 객체
- 객체 지향 프로그래밍 개발 단계
    1. 클래스 설계
    2. 설계된 클래스를 가지고 객체 생성
    3. 생성된 객체 이용

### 클래스 선언

- 객체 구상 후 클래스 이름을 결정
    - 식별자 작성 규칙에 따라 작성
        - 하나 이상의 문자로 이루어질 것
        - 첫 글자에는 숫자 올 수 없음
        - $, _ 외의 특수 문자 사용 불가
        - 자바 키워드 사용 불가

### 객체 생성과 클래스 변수

- 클래스로부터 객체를 생성
    - new 클래스();
    - new 연산자로 메모리 힙 영역에 객체 생성
    - 객체 생성 후 객체 번지가 리턴
        - 클래스 변수에 저장하여 변수 통해 객체 사용 가능
- 클래스의 두 용도
    - 라이브러리 클래스
        - 객체 생성 및 메소드 제공 역할
    - 실행 클래스
        - main() 메소드 제공 역할

### 클래스의 구성 멤버

- 필드 - 객체의 데이터가 저장되는 곳
    - 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
- 생성자 - 객체 생성 시 초기화 역할 담당
    - new 연산자로 호출되는 특별한 중괄호 {} 블록
- 메소드 - 객체의 동작에 해당하는 실행 블록
    - 객체의 동작에 해당하는 중괄호 {} 블록

## 필드

필드는 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳.

### 필드 선언

- 클래스 중괄호 블록 어디서든 존재 가능
- 생성자와 메소드 중괄호 블록 내부에서는 선언 불가
- 변수와 선언 형태 유사하나 변수가 아님! 필드임!
- 초기값은 주어질 수도, 생략할 수도 있음
    - 초기값 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값 설정
        - 정수 타입 필드는 0, 실수 타입 필드는 0.0, boolean타입 필드는 false, 참조 타입은 null.

### 필드 사용

- 필드를 사용한다는 것은 필드값을 읽고 변경하는 작업.
- 클래스 내부 생성자 및 메소드에서 사용하는 경우 : 필드 이름으로 읽고 변경
- 클래스 외부에서 사용하는 경우 : 클래스로부터 객체를 생성한 뒤에 필드 사용 가능

## 생성자

핵심 키워드 : 기본 생성자, 생성자 선언, 매개 변수, 객체 초기화, 오버로딩, this()

핵심 포인트 : 생성자는 new 연산자로 호출되는 중괄호{} 블록이다. 객체 생성 시 초기화를 담당한다.

### 생성자

- 클래스로부터 new 연산자로 객체를 생성할 때 호출되어 객체의 초기화를 담당

### 객체 초기화

- 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것

### 생성자가 성공적으로 실행

- 힙 영역에 객체가 생성되고 객체 번지가 리턴됨.

### 기본 생성자

- 클래스 내부에 생성자 선언 생략할 경우 바이트 코드에 자동 추가(컴파일러에 의해서)
- 클래스에 생성자 선언하지 않아도 `new 생성자()`로 객체 생성 가능

### 생성자 선언

- 매개 변수 선언은 생략할 수도 있고 여러 개 선언할 수도 있음
    
    ```java
    public class Car {
    
    	Car(String model, String color, int maxSpeed){ ... }
    
    }
    ```
    
- 클래스에 생성자가 명시적으로 선언되었을 경우 반드시 선언된 생성자를 호출하여 객체 생성
    
    ```java
    Car myCar = new Car("그랜저", "검정", 300);
    ```
    

### 생성자의 필드 초기화

- 매개 변수 이름은 필드 이름과 유사하거나 동일한 것 사용 권장
- 필드와 매개 변수 이름이 완전히 동일할 경우 this.필드로 표현.
    - this.는 객체 자신의 필드를  가리킴.

### 생성자 오버로딩

- 매개 변수를 달리하는 생성자 여러 개 선언하는 것.
- 외부에서 제공되는 다양한 데이터를 사용하여 객체화하기 위해

### this() 코드

- 생성자에서 다른 생성자 호출
- 필드 초기화 내용을 한 생성자에만 집중 작성하고 나머지 생성자는 초기화 내용 가진 생성자로 호출.

### 키워드로 끝내는 핵심 포인트

- 기본 생성자 : 클래스 선언 시 컴파일러에 의해 자동으로 추가되는 생성자
- 생성자 선언 : 생성자를 명시적으로 선언 가능. 생성자를 선언하면 기본 생성자는 생성되지 않음
- 매개 변수 : 생성자 호출 시 값을 전달받기 위해 선언되는 변수
- 객체 초기화 : 생성자 내부에서 필드값 초기화하거나 메소드 호출해서 사용 준비를 하는 것
- 오버로딩 : 매개 변수 달리하는 생성자를 여러 개 선언
- this() : 객체 자신의 또 다른 생성자를 호출할 때 사용

## 메소드

[핵심 키워드] : 선언부, voide, 매개 변수, 리턴문, 호출, 오버로딩

[핵심 포인트] : 메소드를 선언하고 호출하는 방법에 대해 알아본다.

- 메소드 선언부(signature)
    - 리턴 타입 : 메소드가 리턴하는 결과의 타입 표시
    - 메소드 이름 : 메소드의 기능 드러나도록 식별자 규칙에 맞게 이름 지음
    - 매개 변수 선언 : 메소드 실행할 때 필요한 데이터 받기 위한 변수 선언
    - 메소드 실행 블록 : 실행할 코드 작성
    

### 메소드 선언

- 리턴 타입
    - 메소드를 실행한 후의 결과값의 타입
    - 리턴값 없을 수도 있음
    - 리턴값 있는 경우 리턴 타입이 선언부에 명시
    - 리턴값 존재 여부에 따라 메소드 호출 방법이 다르다.
- 메소드 이름
    - 숫자로 시작하면 안되고, $와 _제외한 특수문자 사용 불가
    - 메소드 이름은 관례적으로 소문자로 시작.
    - 서로 다른 단어가 혼합된 이름일 경우 뒤이어 오는 단어의 첫 글자를 대문자로 작성
- 매개 변수 선언
    - 메소드 실행에 필요한 데이터를 외부에서 받아 저장할 목적
    - 매개 변수가 필요한 경우와 필요 없는 경우가 있다.
- 매개 변수의 개수를 모를 경우
    - 매개 변수를 배열 타입으로 선언
    - 배열 생성하지 않고 값의 목록만 넘겨주는 방식

### 리턴(return)문

- 리턴값이 있는 메소드
    - 메소드 선언에 리턴 타입이 있는 메소드는 리턴문 사용하여 리턴값 지정.
    - return문의 리턴값은 리턴타입이거나 리턴타입으로 변환될 수 있어야 함.
- 리턴값이 없는 메소드 : void
    - void 선언된 메소드에서 return문 사용하여 메소드 실행 강제 종료

### 메소드 호출

- 객체 내부에서 호출
    - 메소드가 리턴값 없거나(void) 있어도 받고 싶지 않은 경우
    - 리턴값 있는 메소드 호출하고 리턴값 받고 싶은 경우
- 객체 외부에서 호출
    - 우선 클래스로부터 객체 생성
    - 참조 변수와 도트 연산자 사용하여 메소드 호출
    

### 메소드 오버로딩

- 같은 이름의 메소드를 여러 개 선언
- 매개값을 다양하게 받아 처리할 수 있도록 하기 위함.
- 매개 변수의 타입, 개수, 순서 중 하나가 달라야 함
- 오버로딩된 메소드 호출할는 겨웅에 JVM은 매개값 타입을 보고 메소드를 선택함
- 매개 변수의 타입, 개수, 순서 같은 경우 매개변수 이름이 달라도 메소드 오버로딩 아님에 주의
- System.out.println() 메소드
    - void println() {}
    - void println(boolean x) {}
    - void println(char x) {}
    - ...

### 키워드로 끝내는 핵심 포인트

- 선언부 : 리턴 타입, 메소드 이름, 매개 변수 선언
- void : 리턴값이 없는 메소드는 리턴 타입으로 void를 기술해야 함
- 매개 변수 : 메소드 호출 시 제공되는 매개값이 대입되어 메소드 블록 실행시 이용됨
- 리턴문 : 메소드의 리턴값을 지정하거나 메소드 실행 종료를 위해 사용할 수 있음.
- 호출 : 메소드를 실행하려면 ‘메소드 이름(매개값)’ 형태로 호출
- 오버로딩 : 클래스 내에 같은 이름의 메소드 여러 개 선언하는 것을 말함.

## 인스턴스 멤버와 정적 멤버

핵심 키워드 : 인스턴스 멤버, this, 정적 멤버, static, final 필드, 싱글톤, 상수

핵심 포인트 : 클래스에 선언된 필드와 메소드가 모두 객체 내부에 포함되는 것은 아니다. 객체가 있어야 사용 가능한 멤버가 있고, 그렇지 않는 멤버도 있다.

- 인스턴스 멤버
    - 객체마다 가지고 있는 멤버
        - 인스턴스 필드 : 힙 영역의 객체 마다 가지고 있는 멤버, 객체마다 다른 데이터를 저장
        - 인스턴스 메소드 : **객체가 있어야 호출 가능한 메소드.** 클래스 코드(메소드 영역)에 위치하지만, 이해하기 쉽도록 객체마다 가지고 있는 메소드라고 생각해도 됨.
    - 객체와 상관없는 멤버, 클래스 코드(메소드 영역)에 위치
        - 정적 필드 및 상수 : 객체 없이 클래스만으로도 사용 가능한 필드
        - 정적 메소드 : 객체가 없이 클래스만으로도 호출 가능한 메소드
        

### 인스턴스(instance) 멤버와 this

- 객체를 생성한 후 사용할 수 있는 필드와 메소드
- this
    - 객체 내에서 인스턴스 멤버에 접근하기 위해 사용
    - 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 필드임을 지정하기 위해 주로 사용

### 정적 멤버와  static

- 정적(static) 멤버
    - 클래스에 고정된 멤버로서 객체 생성하지 않고 사용할 수 있는 필드와 메소드
- 정적 멤버 선언
    - static 타입 필드
    - static 리턴 타입 메소드
- 정적 멤버 사용
    - 클래스 이름과 함께 도트 연산자로 접근
- 인스턴스 멤버와 정적 멤버 선택 기준
    - 객체마다 다를 수 있는 필드값 → 인스턴스 필드로 선언
    - 그렇지 않고 객체마다 다를 필요가 없는 필드값 → 정적필드로 선언
    - 메소드 블록에서 인스턴스 필드 또는 인스턴스 메소드를 사용할 경우 → 인스턴스 메소드로 선언
    - 그렇지 않은 경우 → 정적 메소드로 선언
- 정적 메소드 선언 시 주의할 점
    - 정적 메소드 선언 시 그 내부에 인스턴스 필드 및 메소드 사용 불가
    - 정적 메소드 선언 시 그 객체 자신 참조인 this 키워드 사용 불가
    - 정적 메소드에서 인스턴스 멤버 사용하려는 경우
        - 객체 우선 생성 후 참조 변수로 접근

### 싱글톤

- 전체 프로그램에서 단 하나의 객체만 만들도록 보장하는 코딩 기법
- 싱글톤 작성 방법
    - 클래스 외부에서 new 연산자 통해 생성자 호출하는 것 불가하도록 private 접근 제한자 사용
    - 자신의 타입인 정적 필드 선언 후 자신의 객체 생성해 초기화
    - 외부에서 호출할 수 있는 getInstance() 선언
    - 정적 필드에서 참조하는 자신의 객체를 리턴

### final 필드와 상수

- final 필드
    - 초기값이 저장되면 최종값이 되어 프로그램 실행 도중 수정 불가
    - final 필드의 초기값 주는 방법
        - 단순 값일 경우 필드 선언 시 초기화 (주로 정적 필드(상수)일 경우)
        - 객체 생성시 외부 데이터로 초기화. 필요한 경우 생성자에서 초기화(주로 인스턴스 필드일 경우)
    - 인스턴스 final 필드
        - 객체에 한번 초기화된 데이터를 변경 불가로 만들 경우 : ex) 주민 번호 : 생성자에서 초기화
    - 정적 final 필드 (관례적으로 모두 대문자로 작성)
        - 불변의 값인 상수를 만들 경우 : ex) PI
        

### 키워드로 끝내는 핵심 포인트

- 인스턴스 멤버 : 객체를 생성한 후 사용할 수 있는 필드와 메소드. - 인스턴스 필드. 인스턴스 메소드
- this : 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있음. 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시
- 정적 멤버 : 클래스에 고정된 멤버로서 객체 생성하지 않고 사용할 수 있는 필드와 메소드
- static : 정적 멤버를 선언할 때 사용하는 키워드입니다.
- 싱글톤 : 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우 사용하는 패턴
- final 필드 : 초기값 저장되면 이것이 최종값이 되어 프로그램 실행 도중 수정할 수 없는 필드.
- 상수 : 불변의 값을 저장하는 정적 필드. final static 키워드로 선언

## 패키지와 접근 제한자

[핵심 키워드] : 패키지 선언, import문, 접근 제한자, Getter/Setter

[핵심 포인트] : 프로젝트 개발 시 클래스를 체계적으로 관리하기 위해 패키지를 사용한다. 클래스와 클래스의 멤버를 사용 범위에 맞게 접근 제한자를 활용한다.

- 패키지
    - 패키지의 물리적인 형태는 파일 시스템의 폴더
    - 패키지는 클래스의 일부분으로, 클래스를 유일하게 만들어주는 식별자 역할
    - 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식
    - 클래스의 전체 이름은 패키지 + 클래스 사용해서 다음과 같이 표현
        - 상위패키지.하위패키지.클래스
        - com.mycompany.A
        - com.yourcompany.B

### 패키지 선언

- 패키지 선언
    - 클래스 작성 시 해당 클래스가 어떤 패키지에 속할 것인지를 선언
    - 패키지 이름 규칙
        - 숫자로 시작 불가
        - - 및 $ 제외한 특수문자 사용 불가
        - java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용 불가
        - 모두 소문자로 작성하는 것이 관례
- import문
    - 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속된 경우
    - 해당 패키지 클래스 또는 인터페이스 가져와 사용할 것임을 컴파일러에 통지
    - 패키지 선언과 클래스 선언 사이에 작성
    - 하위 패키지는 별도로 import를 해야함
    - 다른 패키지에 동일한 이름의 클래스가 있을 경우
        - import와 상관없이 클래스 전체 이름을 기술

### 접근 제한자

- 접근 제한자(access modifier)
    - 클래스와 인터페이스 및 이들이 가진 멤버의 접근 제한
    - public 접근 제한자
        - 외부 클래스가 자유롭게 사용할 수 있도록 함
    - protected 접근 제한자
        - 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 함
    - private 접근 제한자
        - 외부에서 사용할 수 없도록 함
    - default 접근 제한
        - 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 함

### 클래스의 접근 제한

- 클래스 접근 제한
    - 같은 패키지 내에서만 사용할 것인지 다른 패키지 내에서도 사용할 수 있도록 할 것인지 결정
- 생성자의 접근 제한
    
    ```java
    public class ClassName {
    	// public 접근 제한
    	public ClassName(...) {...}
    
    	// protected 접근 제한
    	protected ClassName(...) {...}
    
    	// default 접근 제한
    	ClassName(...) {...}
    
    	// private 접근 제한
    	private ClassName(...) {...}
    }
    ```
    

- 필드와 메소드의 접근 제한
    - public / protected / private [static] 타입 필드;
    - public / protected / private [static] 리턴 타입 메소드(...) {...}

### Getter와 Setter 메소드

- 외부에서 객체에 마음대로 접근할 경우 객체의 무결성 깨질 수 있음
- Setter 메소드
    - 외부의 값을 받아 필드의 값을 변경하는 것이 목적
    - 매개값 검증하여 유효한 값만 필드로 저장할 수 있음
- Getter 메소드
    - 외부로 필드값을 전달하는 것이 목적
    - 필드값을 가공해서 외부로 전달할 수도 있음.

### 키워드로 끝내는 핵심 포인트

- 패키지 선언 : 해당 클래스 또는 인터페이스가 어떤 패키지에 속할 것인지를 선언.
- import문 : 다른 패키지에 소속하는 클래스와 인터페이스를 사용할 경우 필요
- 접근 제한자 : 클래스, 인터페이스, 그리고 멤버들을 사용을 제한할 경우 사용
- getter/setter :
    - 필드 값을 외부로 리턴하는 메소드를 Getter (getXXX(), isXXX())
    - 외부에서 값을 받아 필드값을 변경하는 메소드를 Setter(setXXX())